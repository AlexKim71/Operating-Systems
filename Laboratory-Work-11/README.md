
## «Керування процесами-транзакціями в базах даних»

Відповідь --> W1[A] C1 R2[D] R2[A] W2[D] C2 W3[A] R3[B] W3[D] C3 

**Початкові дані з описом операцій транзакцій:**

Згідно з варіантом 5 таблиці 15, маємо наступні три транзакції:

  * **T1:** W[A] C1
  * **T2:** R[D] R[A] W[D] C2
  * **T3:** W[A] R[B] W[D] C3

Де:

  * `R[X]` - операція читання елемента даних X.
  * `W[X]` - операція запису елемента даних X.
  * `C[i]` - операція COMMIT транзакції Ti.

**Опис протоколу 1-го ступеня блокування (1PL):**

Протокол 1-го ступеня блокування (1PL) є одним з базових протоколів керування паралельним доступом до даних у системах керування базами даних (СКБД). Він гарантує серіалізованість виконання транзакцій шляхом введення правил блокування елементів даних:

1.  **Перед тим як транзакція зможе прочитати або записати елемент даних, вона повинна спочатку отримати на нього блокування у відповідному режимі (розділене блокування для читання, ексклюзивне блокування для запису).**
2.  **Після того як транзакція отримала блокування на елемент даних, вона утримує це блокування до моменту свого завершення (операції COMMIT або ROLLBACK).**

Основна мета протоколу 1PL - запобігти конфліктам між транзакціями, які можуть призвести до порушення цілісності даних, таким чином забезпечуючи узгодженість бази даних. Однак, протокол 1PL не гарантує відсутність взаємних блокувань (deadlocks).

**Створення історії квазіпаралельного успішного виконання:**

Для створення квазіпаралельної історії, ми будемо чергувати операції транзакцій, дотримуючись правил 1PL. Ми повинні переконатися, що жодна транзакція не намагається отримати блокування на елемент даних, який вже заблокований іншою транзакцією в несумісному режимі.

**Історія квазіпаралельного успішного виконання для 1PL (Варіант 5):**
### 2.1 Теоретичне завдання зі створення історій виконання транзакцій
### "2.1.1 Створити історію квазіпаралельного успішного виконання транзакцій для протоколу 1-го ступеня блокування."

// Початкові дані транзакцій (для довідки)
// T1: W[A] C1
// T2: R[D] R[A] W[D] C2
// T3: W[A] R[B] W[D] C3

// Історія до першої фіксації (C1 транзакції T1):
// W1[A] C1

// Таблиця блокування транзакцій до моменту першої фіксації (C1):
// Транзакція T1 здійснила запис на елемент даних A і утримує ексклюзивне блокування.

char* lock_table[] = {
    "A: X(T1)" // Елемент даних A заблоковано на запис (X) транзакцією T1
};

int lock_table_size = sizeof(lock_table) / sizeof(lock_table[0]);

// Пояснення:
// До моменту фіксації змін транзакцією T1 (операція C1),
// транзакція T1 виконала запис на елемент даних A (W1[A]).
// Відповідно до протоколу 1-го ступеня блокування,
// T1 повинна отримати ексклюзивне блокування (X) на елементі A перед записом.
// Це блокування утримується до завершення транзакції (C1).
// Тому таблиця блокування на момент першої фіксації відображає,
// що елемент даних A заблоковано транзакцією T1 в режимі ексклюзивного доступу.

### "2.1.2 Під час опису історії описати таблицю блокування транзакцій до моменту першої фіксації змін однієї з транзакцій у вигляді масиву на мові програмування С, наприклад, використовуючи масив char* lock_table."

```c
char* lock_table[] = {
    "T1 -> players",
    "T2 -> teams",
    "T4 -> matches"
};
```
**Висновок:**

До моменту першої фіксації змін (COMMIT), яка відбулася у транзакції T2, у системі було встановлено лише три активні блокування: T1 успішно заблокувала таблицю players, T2 — таблицю teams, а T4 — таблицю matches. Інші транзакції намагалися отримати блокування на вже зайняті ресурси, тому очікували, і їх блокування не були активними на цей момент. Таким чином, до першої фіксації у таблиці блокувань фігурують лише три транзакції з успішно отриманими блокуваннями.

### "2.1.3 Для створеної історії з попереднього завдання визначити наявність Deadlock- стану транзакцій, створивши граф очікування транзакцій, та зробити відповідний висновок. Представити граф у вигляді масиву на мові програмування С, наприклад, використовуючи масив int wait."

```c
int wait[4][4] = {
    // T1 T2 T3 T4
    { 0, 1, 0, 0 }, // T1 → T2
    { 1, 0, 0, 0 }, // T2 → T1
    { 0, 0, 0, 0 }, // T3
    { 0, 0, 0, 0 }  // T4
};
```
**Пояснення:**

1)У наведеній історії транзакцій:
- T1 блокує таблицю players, а потім намагається отримати блокування на teams, яка вже зайнята T2.
- T2 блокує таблицю teams, а потім намагається заблокувати players, яка вже зайнята T1.
Це створює циклічну залежність:
T1 → T2 і T2 → T1 — тобто, обидві транзакції чекають одна на одну.

**Висновок:**

У системі виник стан взаємного блокування (deadlock) між транзакціями T1 та T2, що робить подальше виконання неможливим без зовнішнього втручання (наприклад, примусового завершення однієї з транзакцій).
```
```

### Завдання 2.1.4: Історія квазіпаралельного успішного виконання транзакцій для протоколу 2-го ступеня блокування (Варіант 5)

**1)Deadlock при доступі до одного і того ж елемента B:**
```c
char* deadlock_history1[] = {
    "S1[B]",     // T1 бере shared lock на B
    "r1[B]",     // T1 читає B
    "S2[B]",     // T2 бере shared lock на B
    "r2[B]",     // T2 читає B
    "X1[B]–Wait",// T1 хоче ексклюзивний lock — чекає, бо S2[B] активний
    "X2[B]–Wait" // T2 також хоче ексклюзивний lock — чекає, бо S1[B] активний => DEADLOCK
};
```

**2)Deadlock при доступі до різних елементів у зворотному порядку:**

```c
char* deadlock_history2[] = {
    "S1[B]",     // T1 бере shared lock на B
    "r1[B]",     // T1 читає B
    "S2[D]",     // T2 бере shared lock на D
    "r2[D]",     // T2 читає D
    "X1[D]–Wait",// T1 хоче ексклюзивний lock на D — чекає, бо S2[D]
    "X2[B]–Wait" // T2 хоче ексклюзивний lock на B — чекає, бо S1[B] => DEADLOCK
};
```



**1)Deadlock на одному об’єкті B (T1 і T2 обидва хочуть X[B]):**
```c
int wait1[][2] = {
    {0, 1},
    {1, 0}
};
```

**2) Deadlock на двох об’єктах B і D у зворотному порядку доступу:**

```c
int wait2[][2] = {
    {0, 1},
    {1, 0}
};
```

### 2.1.5. Аналіз Deadlock-стану та граф очікування для історії 2PL (Варіант 5)

**Історія виконання для 2PL (Варіант 5):**

**Аналіз Deadlock-стану:**

У створеній історії квазіпаралельного виконання для протоколу 2-го ступеня блокування, транзакції виконуються послідовно, хоча їхні операції чергуються. Кожна транзакція отримує необхідні блокування та утримує їх до завершення (COMMIT).

Розглянемо можливі причини виникнення Deadlock:

* **Циклічне очікування блокувань:** Транзакція T1 очікує на блокування, яке утримує T2, T2 очікує на блокування, яке утримує T3, і T3 очікує на блокування, яке утримує T1.

У наведеній історії:

* `T1` отримує блокування на `A` і завершується.
* `T2` отримує блокування на `D`, потім на `A`, потім намагається записати `D` і завершується.
* `T3` отримує блокування на `A`, потім на `B`, потім на `D` і завершується.

На жодному етапі виконання жодна транзакція не очікує на блокування, яке утримує інша транзакція, що, в свою чергу, очікує на блокування першої транзакції. Тому **стан Deadlock у цій конкретній історії відсутній**.

**Граф очікування транзакцій:**

Оскільки Deadlock відсутній, граф очікування транзакцій буде порожнім. Жодна транзакція не має вихідних ребер до іншої транзакції, що відображає відсутність очікування блокувань.

**Представлення графу очікування у вигляді масиву на мові C:**

```c
// Розмір масиву відповідає кількості транзакцій (3)
int wait_graph[3][3] = {
    {0, 0, 0}, // T1 не очікує на T1, T2 або T3
    {0, 0, 0}, // T2 не очікує на T1, T2 або T3
    {0, 0, 0}  // T3 не очікує на T1, T2 або T3
};

// Пояснення:
// Елемент wait_graph[i][j] = 1 означав би, що транзакція Ti очікує на блокування,
// яке утримує транзакція Tj. Значення 0 означає відсутність очікування.
// Оскільки Deadlock відсутній, всі елементи масиву дорівнюють 0.
```

**Висновок:**

Для створеної історії квазіпаралельного успішного виконання транзакцій з використанням протоколу 2-го ступеня блокування, **стан Deadlock відсутній**. Граф очікування транзакцій є порожнім, що підтверджує відсутність циклічного очікування блокувань між транзакціями. Протокол 2PL, при правильному застосуванні, запобігає виникненню Deadlock, хоча конкретна історія виконання також відіграє важливу роль.
```
```
### 2.2 Налаштування бази даних
### "2.2.1 Встановити в ОС Linux програмний пакунок з СКБД PostgreSQL та підключитись до ОС від імені користувача postgres."

![image](https://github.com/user-attachments/assets/fbac445d-1d84-400c-80e8-03cbc4594948)

### 2.2.2 Створити БД із назвою, яка співпадає з назвою вашого навчального Github-репозиторія із суфіксом _db, наприклад, ai247-blazhko_db.

![image](https://github.com/user-attachments/assets/2bc28161-0f3b-4d9a-bbf9-f80940e58bed)

### 2.2.3 Створити користувача СКБД PostgreSQL з повноваженнями адміністратора на ім’я, яке співпадає з з назвою вашого навчального Github-репозиторія, наприклад, ai247-blazhko.

![image](https://github.com/user-attachments/assets/ee47e555-2ea2-47ac-b360-7751e77001cf)

### "2.2.4 Встановити з’єднання зі створеною БД від імені створеного користувача."

![image](https://github.com/user-attachments/assets/913fc9d6-eca9-4e05-9fed-05a4734f9308)

### 2.2.5 Виконати команди отримання імені поточного користувача СКБД та назви БД.

![image](https://github.com/user-attachments/assets/eeae22d4-2f3f-4800-b0cd-05a7fecfb869)

### 2.2.6 У відповідності із варіантом з таблиці 16 створити реляційну таблицю.

![image](https://github.com/user-attachments/assets/3acba01d-5fd0-457f-8105-52bd8d59a89b)

### 2.2.7 У відповідності із варіантом з таблиці 16 додати рядок в реляційну таблицю.

![image](https://github.com/user-attachments/assets/3a756229-03ba-4dde-8bf6-1705ba89521e)

### 2.2.8 Створити ще одну операцію внесення рядка в таблицю, який буде відрізнятися значеннями всіх змінних (стовпчиків) від прикладу з варіанту, а одна із змінних повинна враховувати значення із транслітерацією вашого прізвища.

![image](https://github.com/user-attachments/assets/faa2308e-75bb-4fd2-964f-0ab1c1e981bd)

### 2.2.9 Переглянути зміст таблиці, враховуючи всі стовпчики всіх рядків таблиці.


![image](https://github.com/user-attachments/assets/e91668cb-3c54-481b-8990-3d375dd4bf3c)


### 2.3 Керування квазіпаралельним виконанням транзакцій з використанням команд блокування

### 2.3.1 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_1.sql»,
### наприклад, blazhko_transaction_lock_1.sql, та додати до нього операції двох транзакцій,
### кожна з яких повинна включати наступні операції:
### − операція блокування для протоколу 1-го ступеня блокування;
### − операція читання всіх стовпчиків першого рядку таблиці;
### − операція зміни значення другого стовпчика таблиці у першому рядку;
### − повторна операція читання всіх стовпчиків першого рядку таблиці;
### − операція фіксації всіх виконаних операцій.

![image](https://github.com/user-attachments/assets/81a7d941-292d-4855-94a9-b960cfbbfa2b)

### 2.3.2 У двох псевдотерміналах виконати операції транзакцій при їх квазіпаралельному режимі роботи за умови, що одна з транзакція стартує першою.

![image](https://github.com/user-attachments/assets/4dc85b9f-bdc8-4a51-a838-0d023f6a4fd4)
![image](https://github.com/user-attachments/assets/e5f1dce7-6e01-4970-b874-207a6e308855)

### 2.3.3 Повторити роботу транзакцій, але у першій транзакції замість операції фіксації виконати операцію скасування всіх операцій транзакції.
![image](https://github.com/user-attachments/assets/4d761256-b9cf-4e4e-8b50-3a756b6833de)
![image](https://github.com/user-attachments/assets/d74ecd75-77ec-4d45-afbc-7f20d071bf24)

### 2.3.4 Створити файл з назвою за шаблоном «ваше прізвище_transaction_lock_2.sql», наприклад, blazhko_transaction_lock_2.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже враховуючи протокол 2-го ступеня блокування.
![image](https://github.com/user-attachments/assets/527b812f-98f7-42a9-8679-7023488e00ac)

### 2.3.5 Повторити роботу транзакцій з використанням протоколу 2-го ступеня блокування, але з додатковим параметром NOWAIT.
![image](https://github.com/user-attachments/assets/51701425-9956-48f1-9d53-e721e5c0c188)
![image](https://github.com/user-attachments/assets/68c467a4-3cf0-4630-9815-a07bc2d66cf3)


### 2.4.1 Створити файл з назвою за шаблоном «ваше прізвище_deadlock.sql»,
### наприклад, blazhko_deadlock.sql, зі змістом файлу, створеного у пункті 2.3.1, але вже
### модифікованого так, щоб транзакції призводили до Deadlock-стану.
![image](https://github.com/user-attachments/assets/84f2fcbf-7cf2-4601-b0ed-ba1d0b3d4734)
![image](https://github.com/user-attachments/assets/4b3628d8-4152-4108-9de4-f67a0fe95d5a)
### 2.4.2 Виконати модифіковані транзакції.
### Проаналізувати реакцію СКБД на операцію зміни значення стовпчика для
### транзакції, яка виконувалася пізніше (призвела до Deadlock-стану), та надати висновки за
### результатами аналізу з урахуванням ідентифікаторів процесів та номерів транзакцій.

Висновок за результатами аналізу Deadlock-стану полягає в тому, що СКБД PostgreSQL ефективно виявляє ситуації взаємного блокування (Deadlock) між транзакціями. При виявленні Deadlock, СКБД автоматично втручається для розблокування системи, скасовуючи одну з транзакцій-учасниць.
У нашому випадку, транзакція, яка намагалася отримати виключне блокування на таблицю airplane другою (і, таким чином, призвела до Deadlock-стану), була обрана як жертва та скасована. Повідомлення про помилку чітко вказало ідентифікатори процесів (PID) обох транзакцій та ресурси (таблицю airplane), на які вони чекали, утримуючи при цьому блокування, необхідні іншій транзакції.
Операція зміни значення стовпчика (UPDATE airplane SET model = 'Deadlock-2' WHERE a_id = 2;) в транзакції, що призвела до Deadlock, не була виконана. Транзакцію було скасовано до досягнення цієї команди. Це підтверджує, що при виникненні Deadlock, незавершені зміни скасованої транзакції не вносяться до бази даних, що забезпечує консистентність даних.
Таким чином, механізм виявлення та усунення Deadlock в PostgreSQL є важливим для забезпечення надійної та стабільної роботи багатокористувацької системи керування базами даних. Розробники повинні враховувати можливість виникнення Deadlock при проектуванні складних транзакцій та вживати заходів для їхнього запобігання (наприклад, дотримуватися узгодженого порядку отримання блокувань).
