
// pipe_read.c
// Програма для читання з неіменованого каналу.
// Приймає дескриптор файлу для читання як аргумент командного рядка.

#include <stdio.h>  // Для printf, fprintf, perror
#include <stdlib.h> // Для EXIT_SUCCESS, EXIT_FAILURE, atoi
#include <unistd.h> // Для read, getpid, close
#include <string.h> // Для strlen (хоча не використовується для отриманого повідомлення напряму)

#define BUFFER_SIZE 256 // Максимальний розмір повідомлення, яке може бути отримано

int main(int argc, char *argv[])
{
    int read_fd;              // Змінна для зберігання дескриптора файлу для читання
    char buffer[BUFFER_SIZE]; // Буфер для зберігання прочитаних даних
    ssize_t bytes_read;       // Кількість прочитаних байтів
    // Використовуємо ваше прізвище "Vyacheslavovich" для виводу, як це було раніше
    char *surname = "Vyacheslavovich";

    // ---- Крок 1: Отримати повідомлення з неіменованого каналу
    //            з використанням значення, переданого через аргумент командного рядка ----

    // Перевіряємо, чи був переданий необхідний аргумент (дескриптор файлу)
    if (argc != 2)
    {
        fprintf(stderr, "Помилка: Необхідно передати дескриптор файлу для читання як аргумент.\n");
        fprintf(stderr, "Використання: %s <read_file_descriptor>\n", argv[0]);
        return EXIT_FAILURE;
    }

    // Перетворюємо рядок-аргумент на ціле число (дескриптор файлу)
    read_fd = atoi(argv[1]);

    // ---- Крок 2: Вивести на екран повідомлення типу "I`m child process of Surname with pid=" ----
    printf("I'm child process of %s with pid=%d\n", surname, getpid());

    // Читаємо дані з каналу в буфер.
    // sizeof(buffer) - 1: залишаємо місце для нульового термінатора,
    // щоб гарантувати коректність рядка, якщо повідомлення заповнить весь буфер.
    bytes_read = read(read_fd, buffer, sizeof(buffer) - 1);

    if (bytes_read == -1)
    {
        // Помилка читання з каналу
        perror("Помилка читання з неіменованого каналу");
        close(read_fd); // Важливо закрити дескриптор навіть у разі помилки
        return EXIT_FAILURE;
    }
    else if (bytes_read == 0)
    {
        // Прочитано 0 байтів. Це означає, що записуючий кінець каналу був закритий,
        // і більше даних не буде надходити.
        printf("Кінець файлу каналу (пишучий кінець був закритий).\n");
    }
    else
    {
        // Додаємо нульовий термінатор, щоб вивід `buffer` як C-рядка був безпечним.
        buffer[bytes_read] = '\0';
        printf("Отримано повідомлення: \"%s\"\n", buffer);
    }

    // ---- Крок 3: Вивести на екран повідомлення, в якому вказано розмір повідомлення ----
    printf("Розмір отриманого повідомлення: %zd байтів.\n", bytes_read);

    // Закриваємо дескриптор файлу для читання, оскільки він більше не потрібен цьому процесу.
    close(read_fd);

    return EXIT_SUCCESS; // Успішне завершення програми
}