### 2.1 Перегляд інформації про процеси
![Screenshot_$timestamp_3](https://github.com/user-attachments/assets/91dbbbec-116e-4953-8ba1-1086b0c14b53)
Рис. 1 - "2.1.1 Створити C-програму з назвою за шаблоном «ваше прізвище_process_info.c»,
наприклад, blazhko_process_info.c яка виводить на екран таку інформацію:
− ідентифікатор групи процесів, до якої належить процес:
− ідентифікатор процесу, що викликав цю функцію;
− ідентифікатор parent-процесу;
− ідентифікатор користувача процесу, який викликав цю функцію;
− ідентифікатор групи користувача процесу, який викликав цю функцію.
Скомпілювати створену С-програму та перевірити її роботу."
![image](https://github.com/user-attachments/assets/5e777dd7-9570-41a6-9150-5fd802c1d1f7)
Рис.2 - "2.1.2 Запустити дві копії програми у двох режимах за прикладами з рисунку 4:
− паралельне виконання двох процесів;
− конвеєрне виконання двох процесів.
Переглянути результат роботи програми у двох режимах, порівняйте значення
ідентифікаторів груп процесів для різних процесів та зробити відповідні висновки за
результатами порівнянь, які вказати у підпису до відповідного рисунку зі знімком екрану."
![image](https://github.com/user-attachments/assets/fef7529a-8844-4a9b-88e8-4cdc155509d9)
Рис.3 - "2.2.1 Створити C-програму, яка породжує процес та замінює образ процесу на
команду у відповідності із варіантом з таблиці 3. Назва програми повинна співпадати з
назвою команди з таблиці 3, але з додатком у вигляді транслітерації вашого прізвища,
наприклад, touch_blazhko.c
Перед включенням відповідної команди з таблиці 3 до програмного коду перевірте
правильність її роботи зі звичайного командного рядку, щоб зрозуміти, що вона повинна
виводити на екран.
У програмі необхідно виконати наступне:
1) child-процес повинен вивести на екран повідомлення типу «the child of Students`
Surname executes: команда», наприклад, «the child of Blazhko executes: echo»;
2) заміна програмного образу child-процесу через функцію execv з урахуванням
аргументів команди, приклади яких наведено у стовпчику таблиці 3 (функція повинна
забезпечити виконання відповідної команди з урахуванням двох аргументів, значення яких
буде розміщено у двох елементах масиву);
3) щоб повідомлення child-процесу не з’являлося пізніше виконання функції execv
через окремі затримки у процесах рекомендується перед функцією execv додати функцію
затримки, наприклад, sleep(1)."
![image](https://github.com/user-attachments/assets/bdead889-0ba5-4209-ad2d-d1de27e3a547)
Рис.4 - "2.2.2 Скомпілювати програму та перевірити її роботу.
Програма повинна виконуватися без помилок."
### 2.3 Обмін сигналами між процесами
![image](https://github.com/user-attachments/assets/b6f993eb-9eb8-4595-8ef7-1d529169e6d7)
Рис.5 - "2.3.1 Створити C-програму з назвою «ваше прізвище_get_signal», в якій процес
очікує отримання сигналу SIGUSR2 та виводить повідомлення типу «Process of Students`
Surname got signal» після отримання сигналу, де замість слова Students` Surname в
повідомленні повинно бути ваше прізвище в транслітерації."
![image](https://github.com/user-attachments/assets/06136bc8-46d3-4d15-9c5f-b90de62b789e)
Рис.6 - "2.3.2 Скомпілювати програму та запустити її."
![image](https://github.com/user-attachments/assets/95f82700-f663-4322-9850-e413e46733e6)
Рис.7 - "2.3.3 Використовуючи інший псевдотермінал, створити C-програму з назвою «ваше
прізвище_set_signal», яка надсилає сигнал SIGUSR2 процесу, запущеному в попередньому
пункті завдання."
![image](https://github.com/user-attachments/assets/90032048-a24d-4cac-9572-fc5b0fff8b95)
Рис.8 - "2.3.4 Скомпілювати другу створену С-програму та запустити її в іншому
псевдотерміналі, проаналізувавши повідомлення, які в першому псевдотерміналі виводить
перша програма.
Завершити процес, запущений в попередньому пункті завдання."
### 2.4 Створення процесу-сироти
![image](https://github.com/user-attachments/assets/ce28551d-2f8d-404c-8b58-305d38e3aa3c)
Рис.9 - "2.4.1 Створити C-програму з назвою «ваше прізвище_orphan», в якій parent-процес
несподівано завершується раніше child-процесу. Parent-процес повинен очікувати
завершення n+1 секунд.
Child-процес повинен в циклі (2*n+1) разів із затримкою в 1 секунду виводити
повідомлення, наприклад, «Parent of Students` Surname», за шаблоном як в попередньому
завданні, і додатково виводити PPID parent-процесу.
Значення n – номер вашого варіанту."
![image](https://github.com/user-attachments/assets/036e6be9-96c5-4eea-83c0-3bdc25fd3557)
Рис.10 - "2.4.2 Скомпілювати програму та перевірити її роботу.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."
*Висновок:*
Програма створює дочірній процес за допомогою системного виклику fork().
Parent-процес очікує протягом n + 1 секунд (у даному випадку 6 секунд) перед завершенням.
Дочірній процес виконує цикл протягом 2 * n + 1 разів (у даному випадку 11 разів), роблячи затримку в 1 секунду на кожній ітерації. Це означає, що дочірній процес працюватиме довше, ніж parent-процес.
Коли parent-процес завершує свою роботу, дочірній процес стає orphan-процесом.
Операційна система автоматично перепризначає parent-процесом для orphan-процесу процес з PID 1 (init). Це гарантує, що кожен процес в системі має parent-процес.
Orphan-процес продовжує своє виконання, маючи новим parent-процесом процес init, і його PPID буде змінено на 1.
### 2.5 Створення zombie-процесу
![image](https://github.com/user-attachments/assets/b6142297-ae18-4b38-be40-c6198b0c80da)
Рис.11 - "2.5.1 Створити C-програму з назвою «ваше прізвище_zombie.c», в якій child-процес
несподівано завершується раніше parent-процесу, перетворюється на zombie-процес,
виводячи в результаті повідомлення, наприклад, «I am Zombie-process of Students` Surname»,
за шаблоном як в попередньому завданні."
![image](https://github.com/user-attachments/assets/06d47f7b-81fe-4747-9e85-d37e3ee6e98e)
Рис.12 - "2.5.2 Скомпілювати програму та запустити її у фоновому режимі.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."
*Висновок:*
Програма gavrylov_zombie.c створює дочірній процес за допомогою системного виклику fork().
Дочірній процес негайно завершує свою роботу (exit(EXIT_SUCCESS)).
Parent-процес продовжує виконуватися та викликає sleep(30), тобто спить протягом 30 секунд, не викликаючи функцій wait() або waitpid() для збору статусу завершення дочірнього процесу.
Як видно з виводу команди ps aux | grep gavrylov_zombie, після запуску програми у фоновому режимі (./gavrylov_zombie &), у таблиці процесів з'являється запис про дочірній процес ([gavrylov_zombie] <defunct>). Стан <defunct> (або Z) вказує на те, що процес є zombie-процесом.
Zombie-процес залишається в таблиці процесів, оскільки parent-процес не викликав wait() для отримання його статусу завершення. Він буде видалений з таблиці процесів лише після завершення роботи parent-процесу.
PID zombie-процесу на скріншоті - 23384.
Таким чином, виконання програми gavrylov_zombie.c без належного очікування дочірнього процесу призводить до створення zombie-процесу, що підтверджується станом <defunct> у виводі команди ps.
### 2.6 Попередження створення zombie-процесу
![image](https://github.com/user-attachments/assets/f210ac8f-bd72-4ce8-8e59-10dfd6b19a9f)
Рис.13 - "2.6.1 Створити C-програму з назвою «ваше прізвище_zombie_stop.c», в якій child-
процес також як в попередньому завданні може перетворитися на zombie-процес, але ця
подія вже повинна контролюватися parent-процесом.
Child-процес повинен виводити повідомлення, наприклад, «Child of Students`
Surname is finished», за шаблоном як в попередньому завданні.
Parent-процес повинен очікувати (3*n) секунд.
Значення n – номер вашого варіанту."
![image](https://github.com/user-attachments/assets/1cf987ae-726f-4a76-afd7-bf0c13fa8716)
Рис.14 - "2.6.2 Скомпілювати програму та запустити її у фоновому режимі.
Переглянути вміст таблиці процесів зі станами процесів та зробити висновки."
*Висновok:*
Програма використовує системний виклик fork() для створення дочірнього процесу.
У parent-процесі встановлюється обробник сигналу SIGCHLD. Цей сигнал надсилається parent-процесу, коли один з його дочірніх процесів завершує свою роботу.
Обробник сигналу handle_sigchld використовує неблокуючий виклик waitpid(-1, &status, WNOHANG) у циклі для збору статусу завершення всіх дочірніх процесів, які завершилися. Це дозволяє parent-процесу дізнатися про завершення дочірніх процесів без блокування власного виконання.
Дочірній процес виводить повідомлення про своє завершення та завершується (exit(EXIT_SUCCESS)).
Parent-процес виводить повідомлення про очікування завершення дочірнього процесу та потім входить у нескінченний цикл (while (1) { sleep(1); }), імітуючи виконання інших завдань.
Завдяки встановленому обробнику сигналу SIGCHLD, parent-процес отримує сповіщення про завершення дочірнього процесу та збирає його статус, запобігаючи таким чином утворенню zombie-процесу. При перегляді таблиці процесів після завершення дочірнього процесу, запис про нього не повинен залишатися у стані <defunct>.
Таким чином, програма демонструє механізм обробки сигналу SIGCHLD для своєчасного збору статусу завершених дочірніх процесів, що є ефективним способом запобігання виникненню zombie-процесів.
